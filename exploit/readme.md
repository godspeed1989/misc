## exploit kernel trap

提要：    
2013年３月13日，Suse的安全研究员Sebastian Krahmer发出一封名为：”CLONE_NEWUSER|CLONE_FS root exploit“的邮件，暴出３.8版本的Linux内核存在一个提权漏洞，并给出了poc(proof of concept):    
http://www.openwall.com/lists/oss-security/2013/03/13/10    
该exploit利用了**３.8内核**允许*普通用户*利用`clone(... CLONE_NEWUSER | CLONE_FS,...)`创建新进程的漏洞，巧妙实现提权。该漏洞利用的精妙之处在于：只是利用概念上的定义缺失，不需要费尽心力写复杂的shellcode,仅若干个普通API就实现了提权。    

另一方面, 给力的是，当天内核开发者就及时给出了fix:    
http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e66eded8309ebf679d3d3c1f5820d1f2ca332c71    


漏洞分析：    

1. 　CLONE_NEWUSER与CLONE_FS狼狈为奸.    

用户名字空间(user namespace)是内核容器框架中的一部分。内核容器方便于分隔资源，系统监管以及虚拟化，简单来说，就是把系统资源进行分隔，这样不同容器中的资源互不感知对方，实现有效分隔。而用户名字空间就是其中一种，每个用户名字空间中，都有一套独立的uid系统，这意味着每个空间中有各自的root用户！这也就意味着，在这个名字空间中，进程可以拥有任意权限(capabilities)，包括调用chroot切换根目录。而本来分隔的名字空间类似sandbox,不会带来太多安全问题。但是，3.8内核允许普通用户创建名字空间！这隐隐约约就带来了坏味道！所以，CLONE_NEWUSER就是说，创建的新进程需要独立的用户名字空间。至于CLONE_FS标志，它表示创建的子进程要跟父进程共享文件系统属性，比如有相同的根目录...    
于是，隐患已经埋下，潘多拉的盒子即将被打开......    

2.  chroot, 罪恶之*根*    

前面讲了，两个奇怪的标志一结合，立马带来了隐患。一个是独立的名字空间，一个是共享的文件系统空间，如何让封印于盒子里的怪兽逃出生天呢。工具之一就是chroot!    

chroot 本意是在 Linux 系统中发挥根目录的切换作用，同时带来系统的安全性等好处。比如有玩过lfs或gentoo的同学都知道，当在host环境下搞定新环境的工具链后，一条chroot命令就可以切换到新的环境，然后筚路蓝缕，开始打拼另一片天空。如下：    
```
　　　   ／（ / : 原来的根目录）
　　　　 ｜
    ——————————————————————
   ｜     |       |　　　 ｜
   bin   lib  home/lcx　.....
                   |
               newroot( /home/lcx/newroot : 新的环境的根目录)
                   |
           ———————————
           |　　｜　　｜
　　      bin  lib   usr .....
```
当执行 : `chroot /home/lcx/newroot`    
就将原来的/home/lcx/newroot 变为新环境的根目录。此时，原来的文件系统被掩盖。压迫不再，曾经的旧民翻身，新的政治秩序铺开.它曾是旧社会中的碌碌无为/home/lcx/newroot/bin, 在新的环境中, 却开始发挥中流砥柱的作用。它现在叫/bin。只为自己代言。    

那如果还用原来的名号，会发生什么情况呢？很简单，发生了坐标系平移。    
旧社会的/bin/su,　将被映射成新环境的/home/lcx/newroot/bin/su    
旧社会的/lib/ld-linux.so.2，将被映射成/home/lcx/newroot/lib/ld-linux.so.2    
好,咱花开两朵，先表一枝.　这一厢先按下,稍后再叙.    

3. 　动态链接器ld-linux.so, 引狼入室    
动态库顾名思义就是程序运行才加载依赖的库.　在linux上,这是由一个叫ld-linux.so的家伙来执行加载动态库这项工作的.粗略地讲,ld-linux.so把程序加载与开始执行之间活动,搜索程序用到的库,并映射到程序的进程空间,　以及完成一些符号解析等dirty job, 然后,才把程序流控制权交到程序入口点开始执行.    

并且,ld-linux.so拥有与所执行程序相同的权限.　意思就是,　当程序以有效用户ID运行的,那ld-linux也以root权限运行.    

那ld-linux.so在哪?　它不应该包含在程序的可执行文件中.　因为,如果系统有上千个要用到动态库的程序,哪岂不是有上千份拷贝.    

所以,补充上面的说法,ld-linux.so是在系统中. 在程序运行时,它首先被加载,然后由它加载动态库.    
ls /lib | grep ld-linux (或ls /lib64 | grep ld-linux) 可以看到,    
存在/lib/ld-linux.so.2(我系统32位的,纯64位系统会发现它在/lib64中).    
由它的路径与名称看来,它本身就是一个库(用file命令查它户口,发现它是shared object, ELF格式中的一种, 共享对象,其它库文件同样也是一这种格式).    

这里面隐含着,系统能加载ld-linux.so, 说明系统知道这个ld-linux.so的路径,它藏在哪呢,就在程序执行映象里    
```
$　readelf -l  /bin/ls
```
以上命令读取ls程序的可执行映象,能发现输出结果中出现有Requesting program interpreter: /lib/ld-linux.so.2的字样.    

这里面,它作了一个假设,我要找的动态链接器ld-linux.so它位于*根目录*下的lib目录中.    
居然硬编码了路径!　万一运行过程中这个根目录变了呢,　这路径不就指到别的地方去了?!    
存在这种可能?　可能!　这就是这个exploit的妙处所在.    

4. 　打开魔盒
上面说的这个exploit妙在,巧妙地在程序运行过程中,改变了根路径!    

改变了根路径后,它执行了一个setuid程序su(运行ls -l /bin/su,  你会看到它的权限是这样的:    
-rwsr-xr-x . 其中发现有一位变成了s.　那么这个程序就叫setuid程序.　至于为什么要这个s,网上有详细解说,我就不献丑了),而这个su在运行前是先让ld-linux运行来加载动态库的.    

好了,　前面说了ld-linux路径是硬编码成/lib/ld-linux.so.2的.　但是!　现在根路径已经变了!    
所以,　现在的/lib/ld-linux.so.2已经不是指向真正的ld-linux.so了.    
它现在指向了改变后的根目录下的lib/ld-linux.so.2    
而这个文件,　就是exploit自身!!! (这个就是在改变根路径过程中做的)    

所以,现在相当于又运行了exploit一次,　不过,这次的有效用户ID(EUID)是０.　因为前面说它执行了一个setuid的程序su.    
而在第3节说过,　执行ld-linux时,它拥有跟su一样的权限: 即EUID为0用户,也就是root的权限.　这就是为什么要选用一个setuid权限的程序.    

然后,这重新运行了一次的exploit的进程做了啥呢,　它把自己的uid设为0. 即让自己成为root用户,然后,再运行一次bash.    
此时,　这个shell就是一个root权限的shell了.　僭权成功!!!    


