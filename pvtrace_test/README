# ls
graph.dot     Makefile    stack.c  symbols.c  trace.c
instrument.c  pvt_test.c  stack.h  symbols.h

Compile the pvt_test program:
# make pvt_test

make sure your dumpcore is turned on:

# ulimit -c unlimited
# ./pvt_test
running in test1!
0
1
2
3
4
segment fault (core dumped)

see, the shit is shows up! How do we deal with it? debug it with gdb
core? All right, that's the first solution came out in my brain. let's
see something like this:

#gdb pvt_test core
.............
................................
Core was generated by `./pvt_test'.
Program terminated with signal 11, Segmentation fault.
[New process 6325]
#0  0x00000004 in ?? ()
(gdb) bt
#0  0x00000004 in ?? ()
#1  0x080486eb in test2 () at pvt_test.c:24
Backtrace stopped: previous frame inner to this frame (corrupt stack?)
(gdb)

It works! You know the error was occurs in test2(). And, there's
another convenient way and you dont have to worry about "0x0f^ck9803
in ?? ()" when your program became a big monkey. Now take a look at
trace.txt:

#cat trace.txt
E0x80486eb
E0x804862c
X0x804862c
E0x8048666
X0x8048666

E = Enter, where the entry of the function.  

X = Exit, where the way out of the function. You might be noticed the
last 2 lines points a same linear address:0x8048666

find the function name:

addr2line -e pvt_test -f -s 0x08048666


The rest of things you need to fix it up. That's a pretty useful
tricky I have been using for a while. Hope can kill your segment
fault. The philosophy of the process of debug reminded me an thought
which quoted from underground hacking & cracking hackers: I'll fuck
you if you don't fuck me first. IMOHO, never stop trying to write the
bug-free code(like Prof Donald E.Knuth) even it's a sort of impossible
mission:-)
